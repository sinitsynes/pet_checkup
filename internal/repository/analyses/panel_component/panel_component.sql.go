// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: panel_component.sql

package panel_component

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const create = `-- name: Create :one
INSERT INTO panel_component (panel_id, pet_id, component_id, date_measured, value)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, panel_id, pet_id, component_id, date_measured, value
`

type CreateParams struct {
	PanelID      pgtype.Int4 `json:"panel_id"`
	PetID        pgtype.Int4 `json:"pet_id"`
	ComponentID  pgtype.Int4 `json:"component_id"`
	DateMeasured pgtype.Date `json:"date_measured"`
	Value        float32     `json:"value"`
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (PanelComponent, error) {
	row := q.db.QueryRow(ctx, create,
		arg.PanelID,
		arg.PetID,
		arg.ComponentID,
		arg.DateMeasured,
		arg.Value,
	)
	var i PanelComponent
	err := row.Scan(
		&i.ID,
		&i.PanelID,
		&i.PetID,
		&i.ComponentID,
		&i.DateMeasured,
		&i.Value,
	)
	return i, err
}

const deleteByID = `-- name: DeleteByID :exec
DELETE FROM panel_component
WHERE id = $1
`

func (q *Queries) DeleteByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteByID, id)
	return err
}

const getByID = `-- name: GetByID :one
SELECT id, panel_id, pet_id, component_id, date_measured, value FROM panel_component
WHERE id = $1
`

func (q *Queries) GetByID(ctx context.Context, id int32) (PanelComponent, error) {
	row := q.db.QueryRow(ctx, getByID, id)
	var i PanelComponent
	err := row.Scan(
		&i.ID,
		&i.PanelID,
		&i.PetID,
		&i.ComponentID,
		&i.DateMeasured,
		&i.Value,
	)
	return i, err
}

const listWithFilters = `-- name: ListWithFilters :many
SELECT id, panel_id, pet_id, component_id, date_measured, value FROM panel_component
WHERE ($1::bigint IS NULL OR pet_id = $1)
  AND ($2::bigint IS NULL OR component_id = $2)
  AND ($3::bigint IS NULL OR panel_id = $3)
  AND ($4::date IS NULL OR date_measured >= $4)
  AND ($5::date IS NULL OR date_measured <= $5)
ORDER BY date_measured DESC, id DESC
`

type ListWithFiltersParams struct {
	PetID       pgtype.Int8 `json:"pet_id"`
	ComponentID pgtype.Int8 `json:"component_id"`
	PanelID     pgtype.Int8 `json:"panel_id"`
	DateFrom    pgtype.Date `json:"date_from"`
	DateTo      pgtype.Date `json:"date_to"`
}

func (q *Queries) ListWithFilters(ctx context.Context, arg ListWithFiltersParams) ([]PanelComponent, error) {
	rows, err := q.db.Query(ctx, listWithFilters,
		arg.PetID,
		arg.ComponentID,
		arg.PanelID,
		arg.DateFrom,
		arg.DateTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PanelComponent
	for rows.Next() {
		var i PanelComponent
		if err := rows.Scan(
			&i.ID,
			&i.PanelID,
			&i.PetID,
			&i.ComponentID,
			&i.DateMeasured,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateByID = `-- name: UpdateByID :one
UPDATE panel_component
SET panel_id = coalesce($1, panel_id),
    pet_id = coalesce($2, pet_id),
    component_id = coalesce($3, component_id),
    date_measured = coalesce($4, date_measured),
    value = coalesce($5, value)
WHERE id = $6
RETURNING id, panel_id, pet_id, component_id, date_measured, value
`

type UpdateByIDParams struct {
	PanelID      pgtype.Int4   `json:"panel_id"`
	PetID        pgtype.Int4   `json:"pet_id"`
	ComponentID  pgtype.Int4   `json:"component_id"`
	DateMeasured pgtype.Date   `json:"date_measured"`
	Value        pgtype.Float4 `json:"value"`
	ID           int32         `json:"id"`
}

func (q *Queries) UpdateByID(ctx context.Context, arg UpdateByIDParams) (PanelComponent, error) {
	row := q.db.QueryRow(ctx, updateByID,
		arg.PanelID,
		arg.PetID,
		arg.ComponentID,
		arg.DateMeasured,
		arg.Value,
		arg.ID,
	)
	var i PanelComponent
	err := row.Scan(
		&i.ID,
		&i.PanelID,
		&i.PetID,
		&i.ComponentID,
		&i.DateMeasured,
		&i.Value,
	)
	return i, err
}
